<!doctype html><html lang=tr dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>.NET Core, .NET Standard ve Felsefe Taşı - Part II | Fatih Doğan</title><meta name=keywords content=".net,.net core,.net standard,.net framework,felsefe taşı,part,clr,common language runtime,gc,garbage collector,jit compiler,just in time compiler,core fx,.net native,vNext,cross platform,asp.net,pcl,portable class libraries,xamarin"><meta name=description content=".NET Standard neden var? Ondan öncesinde PCL’ler neden var diye sormamız gerekiyor değil mi?"><meta name=author content><link rel=canonical href=https://fatihdgn.com/blog/.net-core-.net-standard-ve-felsefe-ta%C5%9F%C4%B1-part-ii/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://fatihdgn.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fatihdgn.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fatihdgn.com/favicon-32x32.png><link rel=apple-touch-icon href=https://fatihdgn.com/apple-touch-icon.png><link rel=mask-icon href=https://fatihdgn.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=tr href=https://fatihdgn.com/blog/.net-core-.net-standard-ve-felsefe-ta%C5%9F%C4%B1-part-ii/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><script async src="https://www.googletagmanager.com/gtag/js?id=G-64N6ZPXRYS"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-64N6ZPXRYS")</script><style>a{text-decoration:underline}</style><meta property="og:title" content=".NET Core, .NET Standard ve Felsefe Taşı - Part II"><meta property="og:description" content=".NET Standard neden var? Ondan öncesinde PCL’ler neden var diye sormamız gerekiyor değil mi?"><meta property="og:type" content="article"><meta property="og:url" content="https://fatihdgn.com/blog/.net-core-.net-standard-ve-felsefe-ta%C5%9F%C4%B1-part-ii/"><meta property="og:image" content="https://fatihdgn.com/images/share.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2017-11-30T00:00:00+00:00"><meta property="og:site_name" content="Fatih Doğan"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fatihdgn.com/images/share.png"><meta name=twitter:title content=".NET Core, .NET Standard ve Felsefe Taşı - Part II"><meta name=twitter:description content=".NET Standard neden var? Ondan öncesinde PCL’ler neden var diye sormamız gerekiyor değil mi?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blog","item":"https://fatihdgn.com/blog/"},{"@type":"ListItem","position":3,"name":".NET Core, .NET Standard ve Felsefe Taşı - Part II","item":"https://fatihdgn.com/blog/.net-core-.net-standard-ve-felsefe-ta%C5%9F%C4%B1-part-ii/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":".NET Core, .NET Standard ve Felsefe Taşı - Part II","name":".NET Core, .NET Standard ve Felsefe Taşı - Part II","description":".NET Standard neden var? Ondan öncesinde PCL’ler neden var diye sormamız gerekiyor değil mi?","keywords":[".net",".net core",".net standard",".net framework","felsefe taşı","part","clr","common language runtime","gc","garbage collector","jit compiler","just in time compiler","core fx",".net native","vNext","cross platform","asp.net","pcl","portable class libraries","xamarin"],"articleBody":"Previously on : .NET Core, .NET Standard ve Felsefe Taşı – Part I\n“It does not do to dwell on dreams and forget to live.” ― J.K. Rowling, Harry Potter and the Sorcerer’s Stone\nJ.K. Rowling’in de dediği gibi, hayal dünyasının içerisinde hayat sürüp yaşamayı unutmak pek olmuyor. İşte PCL’ler hayatımıza böyle girmişti fakat, hayal dünyasının içerisinde, yani teoride mantıklı bir yaklaşım, gerçek hayata uyarlandığında pek de tutarlı olmadı, olamadı. Çok mu abarttım? Olabilir. Ama bu ortada çözülmesi gereken bir durumun olduğu gerçeğini değiştirmiyor.\nSoruyu tekrar alabilir miyim? Ha, şu soru. .NET Standard neden var? Ondan öncesinde PCL’ler neden var diye sormamız gerekiyor değil mi? Çözmeye çalıştığı problem aslında yazdığınız kodların farklı .NET proje tiplerinde kullanılabilmesini sağlamak. Peki neler bu proje tipleri ? .NET Framework, Silverlight, Windows 8 (Metro), Windows Phone, Xamarin, Mono, Universal Windows Platform (UWP), XBox 360, liste daha uzuyor.\nEvet, tabii, güzel fikir. Bir çok ihtiyacı da karşıladı aslında, bu sebeple tamamen kötülemek doğru olmaz ama bir süre sonra bu yaklaşımın eksikliklerini görmeye başladık.\nNerede benim API’ım ? Birinci problem, PCL altyapısı, uygulamayı yazarken kullanabileceğiniz API’ı, desteklemeye çalıştığınız platformların kesişimine göre belirliyor. Bir platformda olan bir API diğer platformda yoksa, o kısım çıkartılıyor. Örneğin Xamarin.iOS, Xamarin.Android ve UWP için yaratayım bir PCL dediğinizde, yapacağınız dosya okuma ve yazma işlemleri artık düşündüğünüz kadar kolay olmuyor. Çünkü bir tarafta System.IO varken, diğer tarafta Windows.Storage var. Kesişimin içerisinde bu iki API da yok. Yani, var da yok. System.IO namespace olarak var ama tanıdık olduğumuz File ve Directory yok mesela. Bu sefer kulağınızı tersten tutmaya ve şuradaki gibi bir guide’ı takip etmeye başlıyorsunuz. Bu da size hayatınızı ve mesleki kararlarınızı sorgulatabiliyor. Halbuki sadece bir dosya okumak istemiştiniz. Bu tür eksiklikleri kapatmak için ortaya PCLStorage gibi paketler çıkıyor ama bu nedense yama hissiyatı yaratıyor. Her kombinasyonda eksik kalan parçalar ve o eksiklikleri kapatmaya çalışan paketler. Sonu gelmez bir döngü.\nAma Cross-Platform oluyor değil mi ? Aslında tam değil. Yazdığınız kod her platform için ayrı ayrı derleniyor. Evet, bir PCL paketini NuGet üzerinden çekerken bütün desteklenen platformlar için derlenen dosyalar da yanında geliyor. Şimdi, bundan iki yıl sonra başka bir .NET platformu çıksa – ki bu hızda giderse hiç de düşük bir olasılık değil – bu paket o platformda çalışacak mı? Tabii ki hayır. Çünkü paketin, bu platform da eklenerek tekrar derlenmesi gerekiyor. Bu arada kaybedebileceğiniz API’ları da bir yandan düşünseniz iyi olur. Onlara da bir “yama” gerekecek.\n.NET Standard Yani bu iki büyük soru işaretine karşı çözüm olacak yapının, öncelikle stabil bir API sunması gerekiyor. Bu ise, hali hazırdaki platformların bu API’ı implemente etmesi gerektiği anlamına geliyor ki geliştirmek istediğim platformlara göre erişebildiğim API oranı azalmasın. Aynı zamanda, sonrasında geliştirilebilecek diğer platformların da aynı API’ı implemente etmesi sağlanırsa, bu yapı için derlenen paketlerin de gelecek platformda çalışması sağlanabilir. Buradan ise yapının görevinin, bütün .NET platformları için ortak bir API sunmak ve bunun devamlılığını sağlamak olduğunu söyleyebiliriz ve iki soru işaretimiz de böylece ortadan kalkmış olur.Sonuç olarak ortaya .NET Standard çıkıyor.\n.NET Standard sayesinde artık tek bir API kullanarak, .NET Standard API’ını implemente etmiş olan bütün .NET platformlarını destekleyebiliyoruz. Yakın zamanda 2.0 versiyonu çıkan .NET Standard tarafından desteklenen API setinin içerisinde Networking, IO ve Threading gibi önemli yapı taşları mevcut.\nBir süre sonra PCL’ler yerini .NET Standard’a bırakacak. Kişisel kanaatim, .NET Standard’ın çok daha iyi bir yaklaşım olduğu yönünde. Umarım yakın zamanda bir standarta daha ihtiyaç duymayız.\n“The truth.” Dumbledore sighed. “It is a beautiful and terrible thing, and should therefore be treated with great caution.” ― J.K. Rowling, Harry Potter and the Sorcerer’s Stone\nBir sonraki yazıda görüşmek üzere.\n","wordCount":"587","inLanguage":"tr","datePublished":"2017-11-30T00:00:00Z","dateModified":"2017-11-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://fatihdgn.com/blog/.net-core-.net-standard-ve-felsefe-ta%C5%9F%C4%B1-part-ii/"},"publisher":{"@type":"Organization","name":"Fatih Doğan","logo":{"@type":"ImageObject","url":"https://fatihdgn.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fatihdgn.com accesskey=h title="Fatih Doğan (Alt + H)">Fatih Doğan</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://fatihdgn.com/en/ title=En aria-label=En>En</a></li></ul></div></div><ul id=menu><li><a href=https://fatihdgn.com/projects/ title=Projeler><span>Projeler</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>.NET Core, .NET Standard ve Felsefe Taşı - Part II</h1><div class=post-description>.NET Standard neden var? Ondan öncesinde PCL’ler neden var diye sormamız gerekiyor değil mi?</div><div class=post-meta><span title='2017-11-30 00:00:00 +0000 UTC'>Kasım 30, 2017</span></div></header><div class=post-content><p><a href="https://www.youtube.com/watch?v=eX-BCKutDh0">Previously on</a> : <a href=../.net-core-.net-standard-ve-felsefe-ta%C5%9F%C4%B1-part-i>.NET Core, .NET Standard ve Felsefe Taşı – Part I</a></p><blockquote><p>“It does not do to dwell on dreams and forget to live.” ― J.K. Rowling, Harry Potter and the Sorcerer’s Stone</p></blockquote><p>J.K. Rowling’in de dediği gibi, hayal dünyasının içerisinde hayat sürüp yaşamayı unutmak pek olmuyor. İşte PCL’ler hayatımıza böyle girmişti fakat, hayal dünyasının içerisinde, yani teoride mantıklı bir yaklaşım, gerçek hayata uyarlandığında pek de tutarlı olmadı, olamadı. Çok mu abarttım? Olabilir. Ama bu ortada çözülmesi gereken bir durumun olduğu gerçeğini değiştirmiyor.</p><h2 id=soruyu-tekrar-alabilir-miyim>Soruyu tekrar alabilir miyim?<a hidden class=anchor aria-hidden=true href=#soruyu-tekrar-alabilir-miyim>#</a></h2><p>Ha, şu soru. .NET Standard neden var? Ondan öncesinde PCL’ler neden var diye sormamız gerekiyor değil mi? Çözmeye çalıştığı problem aslında yazdığınız kodların farklı .NET proje tiplerinde kullanılabilmesini sağlamak. Peki neler bu proje tipleri ? .NET Framework, Silverlight, Windows 8 (Metro), Windows Phone, Xamarin, Mono, Universal Windows Platform (UWP), XBox 360, liste daha uzuyor.</p><p>Evet, tabii, güzel fikir. Bir çok ihtiyacı da karşıladı aslında, bu sebeple tamamen kötülemek doğru olmaz ama bir süre sonra bu yaklaşımın eksikliklerini görmeye başladık.</p><h2 id=nerede-benim-apiım->Nerede benim API’ım ?<a hidden class=anchor aria-hidden=true href=#nerede-benim-apiım->#</a></h2><p><img loading=lazy src=./images/dotnet-today.png alt=".NET Today"></p><p>Birinci problem, PCL altyapısı, uygulamayı yazarken kullanabileceğiniz API’ı, desteklemeye çalıştığınız platformların kesişimine göre belirliyor. Bir platformda olan bir API diğer platformda yoksa, o kısım çıkartılıyor. Örneğin Xamarin.iOS, Xamarin.Android ve UWP için yaratayım bir PCL dediğinizde, yapacağınız dosya okuma ve yazma işlemleri artık düşündüğünüz kadar kolay olmuyor. Çünkü bir tarafta System.IO varken, diğer tarafta Windows.Storage var. Kesişimin içerisinde bu iki API da yok. Yani, var da yok. System.IO namespace olarak var ama tanıdık olduğumuz File ve Directory yok mesela. Bu sefer kulağınızı tersten tutmaya ve <a href=https://developer.xamarin.com/guides/xamarin-forms/application-fundamentals/files/#Saving_and_Loading_Files>şuradaki gibi bir guide’ı</a> takip etmeye başlıyorsunuz. Bu da size hayatınızı ve mesleki kararlarınızı sorgulatabiliyor. Halbuki sadece bir dosya okumak istemiştiniz. Bu tür eksiklikleri kapatmak için ortaya <a href=https://github.com/dsplaisted/PCLStorage>PCLStorage</a> gibi paketler çıkıyor ama bu nedense yama hissiyatı yaratıyor. Her kombinasyonda eksik kalan parçalar ve o eksiklikleri kapatmaya çalışan paketler. Sonu gelmez bir döngü.</p><h2 id=ama-cross-platform-oluyor-değil-mi->Ama Cross-Platform oluyor değil mi ?<a hidden class=anchor aria-hidden=true href=#ama-cross-platform-oluyor-değil-mi->#</a></h2><p>Aslında tam değil. Yazdığınız kod her platform için ayrı ayrı derleniyor. Evet, bir PCL paketini NuGet üzerinden çekerken bütün desteklenen platformlar için derlenen dosyalar da yanında geliyor. Şimdi, bundan iki yıl sonra başka bir .NET platformu çıksa – ki bu hızda giderse hiç de düşük bir olasılık değil – bu paket o platformda çalışacak mı? Tabii ki <strong>hayır</strong>. Çünkü paketin, bu platform da eklenerek tekrar derlenmesi gerekiyor. Bu arada kaybedebileceğiniz API’ları da bir yandan düşünseniz iyi olur. Onlara da bir “yama” gerekecek.</p><h2 id=net-standard>.NET Standard<a hidden class=anchor aria-hidden=true href=#net-standard>#</a></h2><p>Yani bu iki büyük soru işaretine karşı çözüm olacak yapının, öncelikle stabil bir API sunması gerekiyor. Bu ise, hali hazırdaki platformların bu API’ı implemente etmesi gerektiği anlamına geliyor ki geliştirmek istediğim platformlara göre erişebildiğim API oranı azalmasın. Aynı zamanda, sonrasında geliştirilebilecek diğer platformların da aynı API’ı implemente etmesi sağlanırsa, bu yapı için derlenen paketlerin de gelecek platformda çalışması sağlanabilir.
Buradan ise yapının görevinin, bütün .NET platformları için ortak bir API sunmak ve bunun devamlılığını sağlamak olduğunu söyleyebiliriz ve iki soru işaretimiz de böylece ortadan kalkmış olur.Sonuç olarak ortaya <a href=https://github.com/dotnet/standard>.NET Standard</a> çıkıyor.</p><p><img loading=lazy src=./images/dotnet-tomorrow.png alt=".NET Tomorrow"></p><p>.NET Standard sayesinde artık tek bir API kullanarak, .NET Standard API’ını implemente etmiş olan bütün .NET platformlarını destekleyebiliyoruz. Yakın zamanda 2.0 versiyonu çıkan .NET Standard tarafından desteklenen API setinin içerisinde Networking, IO ve Threading gibi önemli yapı taşları mevcut.</p><p><img loading=lazy src=./images/netstandard-apis.png alt=".NET Standard APIs"></p><p>Bir süre sonra PCL’ler yerini .NET Standard’a bırakacak. Kişisel kanaatim, .NET Standard’ın çok daha iyi bir yaklaşım olduğu yönünde. Umarım yakın zamanda bir standarta daha ihtiyaç duymayız.</p><blockquote><p>“The truth.” Dumbledore sighed. “It is a beautiful and terrible thing, and should therefore be treated with great caution.” ― J.K. Rowling, Harry Potter and the Sorcerer’s Stone</p></blockquote><p>Bir sonraki yazıda görüşmek üzere.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://fatihdgn.com/tags/.net/>.net</a></li><li><a href=https://fatihdgn.com/tags/.net-core/>.net core</a></li><li><a href=https://fatihdgn.com/tags/.net-standard/>.net standard</a></li><li><a href=https://fatihdgn.com/tags/.net-framework/>.net framework</a></li><li><a href=https://fatihdgn.com/tags/felsefe-ta%C5%9F%C4%B1/>felsefe taşı</a></li><li><a href=https://fatihdgn.com/tags/part/>part</a></li><li><a href=https://fatihdgn.com/tags/clr/>clr</a></li><li><a href=https://fatihdgn.com/tags/common-language-runtime/>common language runtime</a></li><li><a href=https://fatihdgn.com/tags/gc/>gc</a></li><li><a href=https://fatihdgn.com/tags/garbage-collector/>garbage collector</a></li><li><a href=https://fatihdgn.com/tags/jit-compiler/>jit compiler</a></li><li><a href=https://fatihdgn.com/tags/just-in-time-compiler/>just in time compiler</a></li><li><a href=https://fatihdgn.com/tags/core-fx/>core fx</a></li><li><a href=https://fatihdgn.com/tags/.net-native/>.net native</a></li><li><a href=https://fatihdgn.com/tags/vnext/>vNext</a></li><li><a href=https://fatihdgn.com/tags/cross-platform/>cross platform</a></li><li><a href=https://fatihdgn.com/tags/asp.net/>asp.net</a></li><li><a href=https://fatihdgn.com/tags/pcl/>pcl</a></li><li><a href=https://fatihdgn.com/tags/portable-class-libraries/>portable class libraries</a></li><li><a href=https://fatihdgn.com/tags/xamarin/>xamarin</a></li></ul></footer></article></main><footer class=footer><span>Copyright © 2020, Fatih Doğan.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>